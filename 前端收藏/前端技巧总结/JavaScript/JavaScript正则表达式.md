##JavaScript正则表达式

#### 什么是正则表达式

Regular Expression 使用单个字符串来描述、匹配一系列符合某个句法规则的字符串

说简单了就是按照某种规则去匹配符合条件的字符串，而正则表达式就是这种规则。



#### 正则表达式图形化工具

https://regexper.com，也可以到github上按照教程安装在本地。



#### 1 —— RegExp 对象

JavaScript 通过内置对象 RegExp 支持正则表达式

有两种方法实例化 RegExp 对象

- 字面量，例如 ``` var reg = /\bis\b/g;```
- 构造函数，例如 ``` var reg = new RegExp('\\bis\\b', 'g');```

**修饰符**

- g ：global 全文搜素，不添加则搜索到第一个匹配停止；

- i ：ignore case 忽略大小写，默认大小写敏感；

- m ：multiple lines 多行搜索

  ​

#### 2 —— 元字符

正则表达式由两种基本字符类型组成：

- 原义文本字符
- 元字符：*  +  ?  $  ^  .  |  \  ( )  { }  [ ]

元字符是在正则表达式中有特殊含义的非字母字符

还有一些常见的元字符：

| 字符            | 含义        |
| :------------ | :-------- |
| \t （tab）      | 水平制表符     |
| \v（vertical）  | 垂直制表符     |
| \n（newline）   | 换行符       |
| \r （return）   | 回车符       |
| \0            | 空字符       |
| \f（form feed） | 换页符       |
| \cX（Ctrl + X） | 与X对应的控制字符 |



#### 3 —— 字符类

一般情况下正则表达式一个字符对应字符串一个字符

但也可以使用元字符`[]`来构建一个简单的类

所谓类是指符合某些特性的对象，是泛指，而不是特指某个字符

例如：表达式`[abc]`把字符a或b或c归为一类，表达式可以匹配这类的字符

**字符类取反**

使用元字符`^`创建反向类/负向类

反向类的意思是不属于某类的内柔

例如：表达式`[^abc]`表示不是字符a或b或c的内容



#### 4 —— 范围类

我们可以使用`[a-z]`来连接两个字符表示从 a 到 z 的任意字符

这是个闭区间，也就是包含 a 和 z 本身

在`[]`组成的类内部是可以连着写的，例如`[a-zA-Z]` ，表示从 a 到 z 和从 A 到 Z 的任意字符。

如果要匹配`-`，就写在范围的后面，例如`[0-9-]`表示从0到9的任意数字和`-`



#### 5 —— JS预定义类及边界

正则表达式提供预定义类来匹配常见的字符类。

| 字符          | 等价类             | 含义               |
| ----------- | --------------- | ---------------- |
| .           | [^\r\n]         | 除了回车符和换行符之外的所有字符 |
| \d（digital） | [0-9]           | 数字字符             |
| \D          | [^0-9]          | 非数字字符            |
| \s （space）  | [\t\n\x0B\f\r]  | 空白符              |
| \S          | [^\t\n\x0B\f\r] | 非空白符             |
| \w （word）   | [a-zA-Z_0-9]    | 单词字符（字母、数字、下划线）  |
| \W          | [^a-zA-Z_0-9]   | 非单词字符            |

还提供了几个常用的边界匹配字符。

| 字符            | 含义    |
| ------------- | ----- |
| ^             | 以……开始 |
| $             | 以……结束 |
| \b （boundary） | 单词边界  |
| \B            | 非单词边界 |



#### 6 —— 量词 

| 字符    | 含义              |
| ----- | --------------- |
| ?     | 出现0次或1次（最多出现1次） |
| +     | 出现1次或多次（最少出现1次） |
| *     | 出现0次或多次（任意次数）   |
| {n}   | 出现 n 次          |
| {n,m} | 出现 n 到 m 次      |
| {n,}  | 至少 n 次          |



#### 7 —— JS正则贪婪模式与非贪婪模式

量词在默认的情况下是尽可能多的匹配，这就是贪婪模式。

让正则表达式尽可能**少**的匹配，也就是说一旦成功匹配不再继续尝试就是非贪婪模式。

做法很简单，在量词后面加上“ ？ ”即可。



#### 8 —— 分组

使用`( )`可以达到分组的功能，使量词作用于分组。

使用`|`可以达到或的效果

有了分组之后就可以反向引用。

被正则表达式匹配（捕获）到的字符串会被暂存起来。其中，由分组捕获的串会从1开始编号，我们可以引用这些串。

```javascript
2015-12-25 => 12/25/2015
'2015-12-25'.replace(/(\d{4})-(\d{2})-(\d{2})/g, '$2/$3/$1');
如果直接写$1而没有分组是没有效果的。
$1: 2015
$2: 12
$3: 25
```

**忽略分组**，不希望捕获某些分组，只需要在分组内加上“ ?: ”就可以。这并不意味着该分组内容不属于正则表达式，只是不会给这个分组加编号了而已。



#### 9 —— 前瞻

- 正则表达式从文本头部向尾部开始解析，文本尾部方向，称为“前”。
- 前瞻就是在正则表达式匹配到规则的时候，向前检查是否符合断言，后顾/后瞻方向相反。
- JavaScript 不支持后顾。
- 符合和不符合特定断言称为**肯定/正向**匹配和**否定/负向**匹配。

| 名称   | 正则             | 含义             |
| ---- | -------------- | -------------- |
| 正向前瞻 | exp(?=assert)  | exp 前面是assert  |
| 负向前瞻 | exp(?！assert)  | exp 前面不是assert |
| 正向后顾 | exp(?<=assert) | JavaScript 不支持 |
| 负向后顾 | exp(?<!assert) | JavaScript 不支持 |

assert 也就是断言部分，只是提供判断，而不参加匹配。

```
'a2*34vv'.replace(/\w(?=\d)/g, 'X');
"X2*X4vv"
'a2*34vv'.replace(/\w(?!\d)/g, 'X');
"aX*3XXX"
```



#### 10 —— JS对象属性

- g ：global 是否全文搜素，默认值是 false；
- i ：ignore case 是否大小写敏感，默认值是 false；
- m ：multiple lines 多行搜索，默认值是 false；
- lastIndex ：是当前表达式匹配内容的最后一个字符的下一个位置；
- source ：正则表达式的文本字符串。




#### 11 —— test 和 exec 方法

##### RegExp.prototype.test(str)

- 用于测试字符串参数中是否存在匹配正则表达式模式的字符串；
- 如果存在则返回 true，否则返回 false。

```javascript
var reg = /\w/;
reg.test('a'); // 每次都是true

var reg2 = /\w/g;
reg2.test('a'); // 第1次是true
reg2.test('a'); // 第2次是false
reg2.test('a'); // 第3次是true
reg2.test('a'); // 第4次是false
while(reg2.test('a')) {
  console.log(reg2.lastIndex); // 1,第一次匹配内容的位置是0，lastIndex就是1，再匹配的时候并不是从头开始，而是就从lastIndex开始，也就是位置1，什么都没有，所以是false，第3次lastIndex重置为0。
}

(/\w/g).test('a'); // 每次都是true，但是开销很大
```



##### RegExp.prototype.exec(str)

- 使用正则表达式模式对字符串执行搜索，并将更新全局 RegExp 对象的属性以反映匹配结果；
- 如果没有匹配的文本则返回 null，否则返回一个结果数组。
  - index 声明匹配文本的第一个字符的位置
  - input 存放被检索的字符串 string 

**非全局调用**

- 调用非全局的 RegExp 对象的 exec() 时，返回数组；
- 第1个元素是与正则表达式相匹配的文本；
- 第2个元素是与 RegExp 对象的第1个子表达式相匹配的文本（如果有分组的话）
- 第3个元素是与 RegExp 对象的第2个子表达式相匹配的文本（如果有分组的话），以此类推。

```javascript
var reg3 = /\d(\w)(\w)\d/;
var reg4 = /\d(\w)(\w)\d/g;
var str = '1ab2c3ef4gh5';

reg3.exec(str); //  ["1ab2", "a", "b", index: 0, input: "1ab2c3ef4gh5"]
reg3.exec(str); //  ["1ab2", "a", "b", index: 0, input: "1ab2c3ef4gh5"]
reg3.exec(str); //  ["1ab2", "a", "b", index: 0, input: "1ab2c3ef4gh5"]

reg4.exec(str); //  ["1ab2", "a", "b", index: 0, input: "1ab2c3ef4gh5"]
reg4.exec(str); //  ["3ef4", "e", "f", index: 5, input: "1ab2c3ef4gh5"]
reg4.exec(str); //  null
reg4.exec(str); //  ["1ab2", "a", "b", index: 0, input: "1ab2c3ef4gh5"]
```

当正则表达式使用 "`g`" 标志时，可以多次执行 `exec` 方法来查找同一个字符串中的成功匹配。当你这样做时，查找将从正则表达式的  `lastIndex`属性指定的位置开始。（`test()` 也会更新 `lastIndex` 属性）。



#### 12 —— 字符串对象方法

##### String.prototype.search(reg)

- search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串；
- 方法返回首次匹配项的索引，查找不到返回 -1；
- search() 方法不执行全局匹配，它将忽略标志 g ，并且总是从字符串的开始进行检索。



##### String.prototype.match(reg)

- match() 方法将检索字符串，以找到一个或多个与 RegExp 相匹配的文本；
- RegExp是否具有标志 g 对结果影响很大。

**非全局调用**（返回和 RegExp.exec() 相同的结果）

- 如果 RegExp 没有标志 g ，那么 match() 方法就只能在字符串中执行一次匹配；
- 如果没有找到任何匹配的文本，将返回null；
- 否则它将返回一个数组，其中存放了与它找到的匹配文本有关的信息。
- 返回数组的第一个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式（分组）匹配的文本；
- 除了常规的数组元素之外，返回的数组还含有2个对象属性：
  - index 声明匹配文本的起始字符在字符串的位置
  - input 声明对 stringObject 的引用

**全局调用**

- 如果 RegExp 具有标志 g ，则 match() 方法将执行全局检索，找到的字符串中的所有匹配子字符串；
  - 没有找到任何匹配的子串，则返回 null 
  - 如果找到了一个或多个匹配子串，则返回一个数组
- 数组元素中存放的是匹配的子字符串而不是匹配对象，而且也没有 index 属性和 input 属性。



##### String.prototype.split(reg)

- 使用 split 方法把字符串分割为字符数组

  ```javascript
  'a,b,c,d'.split(','); // ["a", "b", "c", "d"]
  ```

- 在一些复杂的分割情况下可以使用正则表达式解决

  ```javascript
  'a,b,c,d'.split(/,/); // ["a", "b", "c", "d"]
  'a1b2c3d4e'.split(/\d/); //  ["a", "b", "c", "d", "e"]
  ```



##### String.prototype.replace(reg)

- 返回一个由替换值替换一些或所有匹配的模式后的新字符串，注意：原字符串不会改变。


- ```javascript
  语法：str.replace(regexp|substr, newSubStr|function);
  ```

- regexp (pattern)  ：

  一个RegExp 对象或者其字面量。

  该正则所匹配的内容会被第二个参数的返回值替换掉。

- substr (pattern)  ：

  一个要被 newSubStr 替换的字符串。

  其被视为一整个字符串，而不是一个正则表达式。仅仅是第一个匹配会被替换。

- newSubStr (replacement)  ：
   用于替换掉第一个参数在原字符串中的匹配部分的字符串。

  该字符串中可以内插一些特殊的变量名。

- function (replacement)
  一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果。

  ​

  function 会在每次匹配替换的时候调用，有四个参数：

  - 匹配的字符串
  - 正则表达式分组内容，没有分组则没有该参数
  - 匹配项在字符串中的 index
  - 被匹配的原字符串



